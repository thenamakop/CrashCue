import fs from "fs";
import path from "path";
import { execSync } from "child_process";

const SHELLS = [
  { name: "Windows PowerShell", cmd: "powershell" },
  { name: "PowerShell Core (pwsh)", cmd: "pwsh" },
];

function getProfilePath(cmd: string): string | null {
  try {
    return execSync(
      `${cmd} -NoProfile -Command "$PROFILE.CurrentUserCurrentHost"`,
      {
        encoding: "utf8",
        stdio: ["ignore", "pipe", "ignore"],
      },
    ).trim();
  } catch (e) {
    return null;
  }
}

export async function installPowerShell(): Promise<void> {
  if (process.platform !== "win32") {
    console.log("‚ùå PowerShell integration only supported on Windows");
    return;
  }

  console.log("üì¶ Installing CrashCue PowerShell Integration...");

  // 1. Prepare Paths
  let notifierPath = "";
  try {
    const notifierPkg = require.resolve("../../../notifier/package.json");
    notifierPath = path.dirname(notifierPkg);
  } catch (e) {
    notifierPath = path.resolve(__dirname, "../../../notifier");
  }

  const nativeScriptPath = path.join(notifierPath, "native-windows.ps1");
  const soundPath = path.resolve(notifierPath, "../../assets/faahhhhhh.wav");

  // 2. Construct Injection Block
  const startMarker = "# <crashcue-start>";
  const endMarker = "# <crashcue-end>";

  // Template Version: 2 (PS7 Global Coverage)
  const block = `${startMarker}
# DO NOT MODIFY THIS BLOCK MANUALLY
# Generated by CrashCue Installer
# Template Version: 2 (PS7 Global Coverage)

$CrashCueNotifierPS = "${nativeScriptPath}"
$CrashCueSoundPath = "${soundPath}"

$global:CrashCueLastErrorCount = 0
$global:CrashCueLastTriggerTime = Get-Date

function Invoke-CrashCue {
$now = Get-Date
$delta = ($now - $global:CrashCueLastTriggerTime).TotalMilliseconds
if ($delta -gt 150) {
try {
if (Test-Path $CrashCueNotifierPS) {
powershell.exe -NoProfile -ExecutionPolicy Bypass -File $CrashCueNotifierPS -Path $CrashCueSoundPath \`
> $null 2>&1
}
} catch {}
$global:CrashCueLastTriggerTime = $now
}
}

function global:prompt {
$currentErrorCount = $Error.Count
$nativeExit = $LASTEXITCODE

$hadNewError = $currentErrorCount -gt $global:CrashCueLastErrorCount
$nativeFailed = $nativeExit -ne 0

if ($hadNewError -or $nativeFailed) {
    Invoke-CrashCue
}

$global:CrashCueLastErrorCount = $Error.Count
$global:LASTEXITCODE = 0

"PS $($executionContext.SessionState.Path.CurrentLocation)> "

}
${endMarker}`;

  // 3. Install for each shell
  let installedCount = 0;

  for (const shell of SHELLS) {
    const profilePath = getProfilePath(shell.cmd);
    if (!profilePath) {
      // Shell not found or command failed, skip silently (or debug log)
      continue;
    }

    console.log(`üîπ Checking ${shell.name}...`);

    // Backup Profile
    if (fs.existsSync(profilePath)) {
      try {
        const backupPath = `${profilePath}.crashcue.bak`;
        fs.copyFileSync(profilePath, backupPath);
      } catch (e) {
        // Backup failure shouldn't stop install
      }
    } else {
      // Create directory if needed
      const profileDir = path.dirname(profilePath);
      if (!fs.existsSync(profileDir)) {
        fs.mkdirSync(profileDir, { recursive: true });
      }
    }

    // Read & Modify Profile
    try {
      let content = "";
      if (fs.existsSync(profilePath)) {
        content = fs.readFileSync(profilePath, "utf8");
      }

      const regex = new RegExp(
        `${startMarker.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}[\\s\\S]*?${endMarker.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}`,
        "g",
      );

      if (regex.test(content)) {
        // Check for downgrade or legacy template
        const match = content.match(regex);
        if (match) {
          const existingBlock = match[0];
          const isLegacy = !existingBlock.includes("Template Version: 2");
          const isDowngrade = existingBlock.includes("Template Version: 3");

          if (isDowngrade) {
            console.log(
              "   ‚ÑπÔ∏è Newer CrashCue integration detected. Skipping downgrade.",
            );
            continue;
          }

          if (isLegacy) {
            console.log("   ‚ÑπÔ∏è Upgrading legacy CrashCue integration...");
          }
        }
        content = content.replace(regex, block);
        console.log(`   ‚úÖ Updated existing profile: ${profilePath}`);
      } else {
        if (content && !content.endsWith("\n")) {
          content += "\n";
        }
        content += block + "\n";
        console.log(`   ‚úÖ Injected integration: ${profilePath}`);
      }

      fs.writeFileSync(profilePath, content, "utf8");
      installedCount++;
    } catch (err: any) {
      console.error(`   ‚ùå Failed to update profile: ${err.message}`);
    }
  }

  if (installedCount === 0) {
    console.log("‚ö†Ô∏è No PowerShell profiles could be updated.");
  }
}

export async function uninstallPowerShell(): Promise<void> {
  if (process.platform !== "win32") {
    console.log("‚ùå PowerShell integration only supported on Windows");
    return;
  }

  console.log("üóë Uninstalling CrashCue PowerShell Integration...");

  const startMarker = "# <crashcue-start>";
  const endMarker = "# <crashcue-end>";
  const regex = new RegExp(
    `${startMarker.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}[\\s\\S]*?${endMarker.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\r?\\n?`,
    "g",
  );

  let removedCount = 0;

  for (const shell of SHELLS) {
    const profilePath = getProfilePath(shell.cmd);
    if (!profilePath || !fs.existsSync(profilePath)) {
      continue;
    }

    try {
      let content = fs.readFileSync(profilePath, "utf8");

      if (regex.test(content)) {
        content = content.replace(regex, "");
        fs.writeFileSync(profilePath, content, "utf8");
        console.log(`   ‚úÖ Removed integration from: ${profilePath}`);
        removedCount++;
      } else {
        // Nothing to remove
      }
    } catch (err: any) {
      console.error(
        `   ‚ùå Failed to uninstall from ${profilePath}: ${err.message}`,
      );
    }
  }

  if (removedCount === 0) {
    console.log("‚ÑπÔ∏è No integrations found to remove.");
  }
}
